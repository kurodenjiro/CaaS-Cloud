{
  "_from": "node-ssh",
  "_id": "node-ssh@5.1.1",
  "_inBundle": false,
  "_integrity": "sha512-7fp9u6YWCchDo9Kz/CaPVwU+5zSNaKu1wCagcDlmWWSAeE6MlyHAb3wMXbmdG4oujV4bYUE0hLG0HFJ6kktC0A==",
  "_location": "/node-ssh",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "node-ssh",
    "fetchSpec": "latest",
    "name": "node-ssh",
    "raw": "node-ssh",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/node-ssh/-/node-ssh-5.1.1.tgz",
  "_shasum": "e467d31a60c63308a8147602285991f24032287f",
  "_shrinkwrap": null,
  "_spec": "node-ssh",
  "_where": "/home/pavi/Desktop/Cloud-Computing/bhushan/2018-spring-team0/cloud",
  "author": {
    "email": "i@steelbrain.me",
    "name": "steelbrain"
  },
  "bugs": {
    "url": "https://github.com/steelbrain/node-ssh/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "p-map": "^1.2.0",
    "sb-promisify": "^2.0.1",
    "sb-scandir": "^2.0.0",
    "shell-escape": "^0.2.0",
    "ssh2": "^0.5.0"
  },
  "deprecated": false,
  "description": "SS2 with Promises",
  "devDependencies": {
    "babel-core": "^6.26.0",
    "babel-preset-steelbrain": "^5.0.3",
    "eslint-config-prettier": "^2.9.0",
    "eslint-config-steelbrain": "^4.0.1",
    "flow-bin": "^0.63.1",
    "jasmine-fix": "^1.3.1",
    "prettier": "^1.10.2",
    "pty.js": "^0.3.1",
    "sb-babel-cli": "0.1.1",
    "ssh2-streams": "^0.1.20"
  },
  "homepage": "https://github.com/steelbrain/node-ssh#readme",
  "keywords": [
    "sftp",
    "ssh",
    "ssh2"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "node-ssh",
  "optionalDependencies": {},
  "readme": "Node-SSH - SSH2 with Promises\n=========\n\n[![Greenkeeper badge](https://badges.greenkeeper.io/steelbrain/node-ssh.svg)](https://greenkeeper.io/)\n\nNode-SSH is an extremely lightweight Promise wrapper for [ssh2][ssh2], Period.\n\n#### Example\n\n```js\nvar path, node_ssh, ssh, fs\n\nfs = require('fs')\npath = require('path')\nnode_ssh = require('node-ssh')\nssh = new node_ssh()\n\nssh.connect({\n  host: 'localhost',\n  username: 'steel',\n  privateKey: '/home/steel/.ssh/id_rsa'\n})\n/*\n Or\n ssh.connect({\n   host: 'localhost',\n   username: 'steel',\n   privateKey: fs.readFileSync('/home/steel/.ssh/id_rsa')\n })\n if you want to use the raw string as private key\n */\n.then(function() {\n  // Local, Remote\n  ssh.putFile('/home/steel/Lab/localPath', '/home/steel/Lab/remotePath').then(function() {\n    console.log(\"The File thing is done\")\n  }, function(error) {\n    console.log(\"Something's wrong\")\n    console.log(error)\n  })\n  // Array<Shape('local' => string, 'remote' => string)>\n  ssh.putFiles([{ local: '/home/steel/Lab/localPath', remote: '/home/steel/Lab/remotePath' }]).then(function() {\n    console.log(\"The File thing is done\")\n  }, function(error) {\n    console.log(\"Something's wrong\")\n    console.log(error)\n  })\n  // Local, Remote\n  ssh.getFile('/home/steel/Lab/localPath', '/home/steel/Lab/remotePath').then(function(Contents) {\n    console.log(\"The File's contents were successfully downloaded\")\n  }, function(error) {\n    console.log(\"Something's wrong\")\n    console.log(error)\n  })\n  // Putting entire directories\n  const failed = []\n  const successful = []\n  ssh.putDirectory('/home/steel/Lab', '/home/steel/Lab', {\n    recursive: true,\n    concurrency: 10,\n    validate: function(itemPath) {\n      const baseName = path.basename(itemPath)\n      return baseName.substr(0, 1) !== '.' && // do not allow dot files\n             baseName !== 'node_modules' // do not allow node_modules\n    },\n    tick: function(localPath, remotePath, error) {\n      if (error) {\n        failed.push(localPath)\n      } else {\n        successful.push(localPath)\n      }\n    }\n  }).then(function(status) {\n    console.log('the directory transfer was', status ? 'successful' : 'unsuccessful')\n    console.log('failed transfers', failed.join(', '))\n    console.log('successful transfers', successful.join(', '))\n  })\n  // Command\n  ssh.execCommand('hh_client --json', { cwd:'/var/www' }).then(function(result) {\n    console.log('STDOUT: ' + result.stdout)\n    console.log('STDERR: ' + result.stderr)\n  })\n  // Command with escaped params\n  ssh.exec('hh_client', ['--json'], { cwd: '/var/www', stream: 'stdout', options: { pty: true } }).then(function(result) {\n    console.log('STDOUT: ' + result)\n  })\n  // With streaming stdout/stderr callbacks\n  ssh.exec('hh_client', ['--json'], {\n    cwd: '/var/www',\n    onStdout(chunk) {\n      console.log('stdoutChunk', chunk.toString('utf8'))\n    },\n    onStderr(chunk) {\n      console.log('stderrChunk', chunk.toString('utf8'))\n    },\n  })\n})\n```\n\n#### API\n\n```js\ntype PutFilesOptions = {\n  sftp: ?Object,\n  sftpOptions?: Object,\n  concurrency?: number = 5,\n}\ntype PutDirectoryOptions = {\n  sftp: ?Object,\n  sftpOptions?: Object,\n  concurrency?: number = 5,\n  recursive?: boolean,\n  tick?: ((localPath: string, remotePath: string, error: ?Error) => void),\n  validate?: ((localPath: string) => boolean),\n}\ntype ExecOptions = {\n  cwd?: string,\n  options?: Object // passed to ssh2.exec\n  stdin?: string,\n  stream?: 'stdout' | 'stderr' | 'both',\n  onStdout?: ((chunk: Buffer) => void),\n  onStderr?: ((chunk: Buffer) => void),\n}\n\nclass SSH{\n  connect(config: SSH2Config): Promise<this>\n  requestSFTP(): Promise<SSH2SFTP>\n  requestShell(): Promise<SSH2Shell>\n  mkdir(path: string, method: 'sftp' | 'exec' = 'sftp', givenSftp?: Object): Promise<string>\n  exec(command: string, parameters: Array<string>, options: ExecOptions = {}): Promise<Object | string>\n  execCommand(command: string, options: { cwd: string, stdin: string } = {}): Promise<{ stdout: string, options?: Object, stderr: string, signal: ?string, code: number }>\n  putFile(localFile: string, remoteFile: string, sftp: ?Object = null, opts: ?Object = null): Promise<void>\n  getFile(localFile: string, remoteFile: string, sftp: ?Object = null, opts: ?Object = null): Promise<void>\n  putFiles(files: Array<{ local: string, remote: string }>, options: PutFilesOptions = {}): Promise<void>\n  putDirectory(localDirectory: string, remoteDirectory: string, options: PutDirectoryOptions = {}): Promise<boolean>\n  dispose(): void\n}\n```\n\n### Keyboard-interactive user authentication\n\nIn some cases you have to enable keyboard-interactive user authentication. Otherwise you will get an `All configured authentication methods failed` error.\n\n#### Example:\n\n```js\nconst password = 'test'\n\nssh.connect({\n  host: 'localhost',\n  username: 'steel',\n  port: 22,\n  password,\n  tryKeyboard: true,\n  onKeyboardInteractive: (name, instructions, instructionsLang, prompts, finish) => {\n      if (prompts.length > 0 && prompts[0].prompt.toLowerCase().includes('password')) {\n        finish([password])\n      }\n    }\n})\n```\n\n\n\nFor further information see: https://github.com/mscdex/ssh2/issues/604\n\n### License\nThis project is licensed under the terms of MIT license. See the LICENSE file for more info.\n\n[ssh2]:https://github.com/mscdex/ssh2\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/steelbrain/node-ssh.git"
  },
  "scripts": {
    "build": "sb-babel-cli -o lib src",
    "test": "(apm test) && (flow check) && (eslint . ) && (prettier -l '{src,spec}/**/*.js')",
    "watch": "npm run build -- -w"
  },
  "version": "5.1.1"
}
